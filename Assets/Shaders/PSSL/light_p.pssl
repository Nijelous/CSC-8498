#include "ShaderConstants.psslh"
#include "LightData.psslh"


struct VS_OUTPUT
{
	float4 Position		: S_POSITION;
	uint LightID		: TEXCOORD0;
};

SamplerState sampler			: register(s0);

RegularBuffer<sce::Agc::Core::Texture> textures : register(t0);
RegularBuffer<sce::Agc::Core::Buffer> bindlessBuffers		: register(t1);

out float4 albedoLight;
out float4 specularLight;

[CxxSymbol("TestShader::ps")]
void main(VS_OUTPUT vertex) : S_TARGET_OUTPUT
{

	RegularBuffer<LightData> lightBuffer = bindlessBuffers[128];
	LightData light = lightBuffer[vertex.LightID];

	float fragX = (vertex.Position.x + 1) / 2;
	float fragY = (vertex.Position.y + 1) / 2;
	float2 fragCoord = float2(fragX, fragY) * Constants.pixelSize;
	Texture2D<float4> depthTex = Texture2D<float4>(textures[NonUniformResourceIndex(Constants.gBuffDepthIndex)]);
	
	
	float depth = depthTex.Sample(sampler, fragCoord).x;
	float3 ndcPos = float3(fragCoord, depth) * 2.0 - 1.0;
	float4 invClipPos = mul(Constants.inverseViewProjMatrix, float4(ndcPos, 1.0));
	float3 worldPos = invClipPos.xyz / invClipPos.w;

	float dist = length(light.lightPos - worldPos);
	float atten = 1.0 - clamp(dist / light.lightRadius, 0.0, 1.0);

	if(atten == 0.0) {discard;}

	Texture2D<float4> normalTex = Texture2D<float4>(textures[NonUniformResourceIndex(Constants.gBuffNormalIndex)]);
	float3 normal = normalize(normalTex.Sample(sampler, fragCoord).xyz * 2.0 - 1.0);
	float3 incident = normalize(light.lightPos - worldPos);
	//float3 viewDir = normalize(Constants.);


}